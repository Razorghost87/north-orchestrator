"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createIssue = createIssue;
exports.postPlanToIssue = postPlanToIssue;
exports.getLastIssue = getLastIssue;
const rest_1 = require("@octokit/rest");
const config_1 = require("../config");
const store_1 = require("../memory/store");
const [owner, repo] = config_1.config.GITHUB_REPO.split('/');
const octokit = new rest_1.Octokit({ auth: config_1.config.GITHUB_TOKEN });
const LABEL_NAME = 'plan:needed';
// Ensure label exists (idempotent)
async function ensureLabel() {
    try {
        await octokit.issues.getLabel({ owner, repo, name: LABEL_NAME });
    }
    catch {
        await octokit.issues.createLabel({
            owner,
            repo,
            name: LABEL_NAME,
            color: 'e11d48',
            description: 'Awaiting agent-generated plan',
        });
    }
}
async function createIssue(type, description) {
    await ensureLabel();
    const title = `[${type}] ${description.slice(0, 100)}`;
    const body = `## Request\n\n**Type:** \`${type}\`\n\n**Description:**\n${description}\n\n---\n*Submitted via North Orchestrator. Agent meeting in progress...*`;
    const { data } = await octokit.issues.create({
        owner,
        repo,
        title,
        body,
        labels: [LABEL_NAME],
    });
    return { number: data.number, html_url: data.html_url };
}
async function postPlanToIssue(issueNumber, plan, atomicTasks, riskVerdict) {
    const body = `## ðŸ¤– Agent Meeting Complete

## PLAN
${plan}

## ATOMIC TASKS
${atomicTasks}

## RISK VERDICT
${riskVerdict}

---
*Generated by North Orchestrator multi-agent system.*`;
    await octokit.issues.createComment({ owner, repo, issue_number: issueNumber, body });
    // Remove plan:needed label, add plan:ready
    try {
        await octokit.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: LABEL_NAME });
        await octokit.issues.addLabels({
            owner,
            repo,
            issue_number: issueNumber,
            labels: ['plan:ready'],
        });
    }
    catch (err) {
        console.warn('Label update failed (non-fatal):', err.message);
    }
    // Save to memory
    await (0, store_1.saveMeetingSummary)(issueNumber, plan, atomicTasks, riskVerdict);
}
async function getLastIssue() {
    const { data } = await octokit.issues.listForRepo({
        owner,
        repo,
        sort: 'created',
        direction: 'desc',
        per_page: 1,
    });
    if (!data.length)
        return null;
    const issue = data[0];
    return { number: issue.number, html_url: issue.html_url, state: issue.state };
}
//# sourceMappingURL=issues.js.map